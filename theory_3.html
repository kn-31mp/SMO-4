<!DOCTYPE html>
<html lang="uk">
    <head>
        <title>SMO 4</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="css/bootstrap_5.3.2_min.css" />
        <link rel="stylesheet" href="css/main.css" />
    </head>
    <body>
        <div class="container-fluid text-justify bg-body">
            <div class="row">
                <div class="col-9 main_frame">
                    <div class="h1">
                        <div>
                            3. Моделі програм. Методика моделювання ресурсів ОС.
                        </div>
                        <div>
                            Моделі пристроїв-ресурсів і способи їх опису
                        </div>
                    </div>
                    <hr class="border-black" />
                    <p>
                        <h3>Зміст</h3>
                    </p>
                    <p>
                        <a href="#theory_3_1">
                            3.1. Аналітичний спосіб визначення характеристик моделі програми
                        </a>
                    </p>
                    <p>
                        <a href="#theory_3_2">
                            3.2. Обчислення характеристик трудомісткості
                        </a>
                    </p>
                    <p>
                        <a href="#theory_3_3">
                            3.3. Оцінка середньої трудомісткості алгоритмів
                        </a>
                    </p>
                    <p>
                        <a href="#theory_3_4">
                            3.4. Оцінка мінімальної та максимальної трудомісткості алгоритму
                        </a>
                    </p>
                    <p>
                        <a href="#theory_3_5">
                            3.5. Методика моделювання ресурсів ОС
                        </a>
                    </p>
                    <p>
                        <a href="#theory_3_6">
                            3.6. Модель мультиплексного каналу
                        </a>
                    </p>
                    <p>
                        <a href="#theory_3_7">
                            3.7. Моделі селекторних каналів
                        </a>
                    </p>
                    <p>
                        <h3>Методичні вказівки</h3>
                    </p>
                    <p>
                        Рекомендується розглянути такі питання: моделі програм,
                        методика моделювання ресурсів ОС і моделі
                        пристроїв-ресурсів, способи їх опису. При цьому
                        моделювання програм слід виконувати за деякого спрощення
                        випадкових процесів, тобто з використанням тільки
                        математичних очікувань випадкових величин без урахування
                        законів розподілу. Це дасть змогу суттєво спростити
                        математичні вирази в моделях, зробить головну задачу
                        теорії розв'язною аналітично, і водночас з тим похибка
                        результатів при цьому не перевищить 20%.
                    </p>
                    <p>
                        <h3>Моделі програм</h3>
                    </p>
                    <p>
                        До принципів моделювання програм належить принцип, який
                        визначає клас моделей програм і пов'язаний зі
                        стохастичною природою не тільки кількості змінних у
                        програмі, а й характеру обчислювального процесу,
                        породжуваного нею.
                    </p>
                    <p>
                        Конкретна реалізація випадкового процесу залежить від
                        розмірності задачі, розв'язуваної за цією програмою, і
                        значень початкових даних для неї.
                    </p>
                    <p>
                        Цей принцип називається принципом стохастичності потоків
                        заявок на ресурси і, природно, тягне за собою
                        необхідність моделювання ВС відповідно до теорії
                        випадкових процесів.
                    </p>
                    <p>
                        Вимоги до моделей програм можуть бути сформульовані так:
                    </p>
                    <p>
                        1. Модель має з високою достовірністю відображати
                        обчислювальний процес, породжуваний програмою, тобто
                        вона повинна мати впорядковані за часом послідовності
                        запитів на різні типи ресурсів ОС.
                    </p>
                    <p>
                        2. Запити повинні представлятися як реалізації
                        випадкового процесу, тобто виникати у випадкові моменти
                        часу і мати випадкові значення характеристик, що
                        описують ресурс.
                    </p>
                    <p>
                        3. Випадкові величини слід представляти як мінімум
                        їхніми математичними очікуваннями. Під час точного
                        представлення випадкових величин необхідно враховувати
                        їхні закони розподілу.
                    </p>
                    <p>
                        4. У запитах мають бути визначені кількісні показники
                        вимог на ресурси.
                    </p>
                    <p>
                        Моделювання програм будемо виконувати за деякого
                        спрощення випадкових процесів, тобто з використанням
                        тільки математичних очікувань випадкових величин без
                        урахування законів розподілу.
                    </p>
                    <p>
                        Це дасть змогу істотно спростити математичні вирази в
                        моделях, зробить головне завдання теорії розв'язним
                        аналітично, і водночас похибка результатів при цьому не
                        перевищить 20%.
                    </p>
                    <p>
                        Зробимо ще два припущення, що істотно спрощують модель і
                        практично не вносять похибок у розрахунки.
                    </p>
                    <p>
                        1. Приймемо за рівновеликі обчислювальні трудомісткості
                        в операціях підсумовування бітів і пересилання байта;
                    </p>
                    <p>
                        2. Роботу арифметико-логічного пристрою (АЛП) розглянемо
                        в нерозривному зв'язку з оперативною пам'яттю, вважаючи
                        при цьому, що обчислювальна трудомісткість з пересилання
                        інформації між АЛУ й оперативною пам'яттю включена в
                        трудомісткість операції підсумовування бітів.
                    </p>
                    <p>
                        Під час моделювання програми необхідно враховувати
                        логічну організацію її функціонування.
                    </p>
                    <p>
                        На рис. 5.1 показано схему розподілу пам'яті для
                        програми, на рис. 5.2 - циклограма її виконання. З метою
                        спрощення викладу теорії на рис. 5.1 і в наступних
                        викладках розглядається зовнішня пам'ять тільки прямого
                        доступу.
                    </p>
                    <p>
                        Якщо програма не може бути цілком розміщена в
                        оперативній пам'яті через обмежену ємність останньої то
                        вона розділяється на частини
                        <img src="formula/mmm.gif" />, звані завантажувальними
                        модулями, які зберігаються в зовнішній пам'яті як записи
                        <img src="formula/mmm.gif" />, що складають файл
                        <img src="formula/fa1.gif" />, який називається головним
                        файлом.
                    </p>
                    <p>
                        Дані, пов'язані з програмою, поділяються на файли
                        <img src="formula/fa23.gif" />, а файли, в свою чергу,
                        поділяються на записи <i>a1, а2</i>, ...; <i>b1, b2</i>,
                        ...
                    </p>
                    <p>
                        Залежно від способу використання даних при розв'язанні
                        задач розрізняють вхідні та вхідні-вихідні файли.
                    </p>
                    <p>
                        Вхідний файл
                        <img src="formula/fa2.gif" />
                        містить вхідні дані, які тільки читаються з файлу в
                        процесі розв'язання задачі.
                    </p>
                    <p>
                        Вхідні файли існують до початку розв'язання задачі;
                        вихідний файл
                        <img src="formula/fa4.gif" /> - результати розв'язання
                        задачі, що записуються у файл у порядку їх отримання;
                        вхідний-вихідний файл використовується як для читання,
                        так і для завантаження їх у процесі розв'язання задачі;
                        підрозділяється на основні та робочі.
                    </p>
                    <div
                        class="d-flex align-items-center flex-column mb-3 mt-3"
                    >
                        <img src="formula/ris51.gif" />
                        <div class="mt-3">Рис. 5.1</div>
                    </div>
                    <p>
                        Основний файл існує до початку та/або/ після закінчення
                        розв'язання задачі.
                    </p>
                    <p>
                        Робочий файл створюється тільки на період розв'язання
                        задачі і містить у собі проміжні дані, необхідні лише
                        для одного прогону програми.
                    </p>
                    <p>
                        Для розв'язання задачі в оперативній пам'яті виділяється
                        розділ, у якому умовно можна вказати дві частини:
                        область програми та область даних (рис. 5.1).
                    </p>
                    <p>
                        Область програми має ємність, достатню для розміщення
                        підмножини завантажувальних модулів, які повинні
                        одночасно бути присутніми в оперативній пам'яті у
                        процесі розв'язання задачі.
                    </p>
                    <p>
                        Завдання починає виконуватися з моменту завантаження в
                        оперативну пам'ять кореневого (ведучого) модуля
                        <img src="formula/m0.gif" />
                        і передачі йому управління. У деякий момент часу модуль
                        <img src="formula/m0.gif" />
                        може викликати в оперативну пам'ять модуль
                        <img src="formula/malfa.gif" />, який, у свою чергу,
                        може звернутися до модуля
                        <img src="formula/mbeta.gif" />
                        і т.д.
                    </p>
                    <p>
                        У результаті в області програми можуть одночасно
                        знаходиться кілька модулів
                        <img src="formula/m0.gif" />,
                        <img src="formula/malfa.gif" />,
                        <img src="formula/mbeta.gif" />, ...
                        <img src="formula/momega.gif" />.
                    </p>
                    <p>
                        Після завершения роботи модуль
                        <img src="formula/momega.gif" />
                        передає керування модулю, який його викликав, і область
                        пам'яті, яку займає модуль
                        <img src="formula/momega.gif" />, вважається вільною і в
                        неї може бути викликаний черговий модуль.
                    </p>
                    <p>
                        Таким чином, у кожен момент часу в оперативній пам'яті
                        присутня лише частина модулів, що входять до програми.
                    </p>
                    <p>
                        В області виділяється підобласть <i>D1</i>, у якій
                        розміщуються дані, які в основному постійно
                        використовуються в процесі розв'язання задачі.
                    </p>
                    <p>
                        Доступ до даних, розміщених у файлах
                        <i> <img src="formula/fa23.gif" /> </i>, організовується
                        виділенням областей оперативної пам'яті
                        <i
                            ><img src="formula/ajmal.gif" />,
                            <img src="formula/bj.gif" />,
                            <img src="formula/ck.gif" />,
                        </i>
                        званих буферами введення-виведення.
                    </p>
                    <p>
                        Кожен із буферів забезпечує розміщення щонайменше одного
                        запису з відповідного файлу.
                    </p>
                    <p>Для кожного файлу - свій буфер.</p>
                    <p>
                        Запис викликається в буфер командами введення-виведення,
                        після чого дані, включені в цей запис, стають доступними
                        для обробки.
                    </p>
                    <p>
                        Аналогічно, результати, що формуються програмою,
                        заносяться в область буфера
                        <img src="formula/ck.gif" />
                        і в міру формування записів переносяться у вихідні
                        файли.
                    </p>
                    <p>
                        Перед виконанням програми кореневий модуль
                        <img src="formula/m0.gif" />
                        завантажується на початок розділу, виділеного завданню.
                    </p>
                    <p>Порядок виконання програми показано на рис. 5.2.</p>
                    <p>
                        Відрізки на осях часу <i>t</i> позначають періоди
                        активного стану процесів обробки С і звернення до файлів
                        <img src="formula/f123h.gif" />.
                    </p>
                    <p>
                        Виконання програми складається з послідовності періодів
                        обробки інформації та звернення до файлів, що слідують у
                        порядку, вказаному програмою.
                    </p>
                    <p>
                        Тривалість періодів визначається трудомісткістю робіт -
                        кількістю операцій, які має виконати процесор, кількістю
                        операцій, що забезпечують передачу при зверненні до
                        файлу, і швидкодією пристроїв, використовуваних для
                        виконання відповідних робіт.
                    </p>
                    <p>
                        У розпорядження виконуваної програми мають бути
                        представлені необхідні ресурси.
                    </p>
                    <p>
                        Виконання програми, забезпеченої необхідними ресурсами,
                        можна розглядати як послідовність етапів обслуговування
                        запитів програми до пристроїв ЕОМ.
                    </p>
                    <div
                        class="d-flex align-items-center flex-column mb-3 mt-3"
                    >
                        <img src="formula/ris52.gif" />
                        <div class="mt-3">Рис. 5.2</div>
                    </div>
                    <p>
                        Розділи оперативної та зовнішньої пам'яті, закріплені за
                        програмою, залишаються зайнятими протягом усього періоду
                        виконання програми. Пристрої-процесори, системи
                        введення-виведення та зовнішні запам'ятовуючі пристрої
                        використовуються періодично і в проміжки, вільні від
                        обслуговування даної програми, можуть бути надані у
                        розпорядження інших програм.
                    </p>
                    <p>
                        З огляду на вимоги до моделей, прийняті допущення та
                        логічну організацію функціонування програми, модель
                        програми може бути представлена як обчислювальний
                        процес, що складається з послідовності етапів лічби та
                        введення-виведення інформації при зверненні до файлів
                        <img src="formula/f123h.gif" />
                        (Рис. 5.2). Стан обчислювального процесу, що відповідає
                        етапу рахунку, позначимо символом
                        <img src="formula/s0.gif" />, а стани, що відповідають
                        зверненням до файлів
                        <img src="formula/f123h.gif" /> символами
                        <img src="formula/s12h.gif" />. Закінчення
                        обчислювального процесу (ОП) будемо розглядати як
                        перехід процесу в стан <img src="formula/sh1.gif" />, що
                        поглинає обчислювальний процес. У зазначених позначеннях
                        обчислювальний процес - це послідовність станів
                        <img src="formula/f94.gif" />, що змінюються в момент
                        часу <img src="formula/t01m.gif" />, причому
                        <img src="formula/f95.gif" /> и заключний стан процесу
                        <img src="formula/f96.gif" />. Однак поставити у
                        відповідність кожному
                        <img src="formula/f97.gif" />
                        один зі станів
                        <img src="formula/f98.gif" />- непросте завдання,
                        оскільки обчислювальний процес має випадковий характер.
                        Його можна розв'язати порівняно просто, якщо зміну
                        станів описати Марковським ланцюгом: прийняти допущення
                        про відсутність наслідків у обчислювальному процесі.
                        Тоді процес стає Марковським, який визначається множиною
                        властивих йому станів <img src="formula/f99.gif" />,
                        матрицею ймовірностей переходів
                    </p>
                    <p>
                        <img src="formula/f100.gif" />
                    </p>
                    <p>
                        і розподілом імовірностей
                        <img src="formula/a0a1td.gif" /> станів
                        <img src="formula/s0s1td.gif" /> в момент часу
                        <img src="formula/t0mal.gif" />. Будемо вважати, що
                        обчислювальний процес розвивається так у такий спосіб.
                    </p>
                    <p>
                        Починається він зі стану
                        <img src="formula/s0.gif" />, тобто програма починає
                        виконуватися з етапу рахунку. Етап введення-виведення
                        може бути ініційований тільки процесором, тобто може
                        слідувати тільки за етапом рахунку. Це означає, що після
                        кожного етапу введення-виведення слідує етап рахунку.
                        Імовірності початкових станів дорівнюватимуть:
                    </p>
                    <p>
                        <img src="formula/a0a1td.gif" />
                        = (1, 0, 0, ... , 0),
                    </p>
                    <p>а матриця ймовірностей переходів прийме вигляд</p>
                    <p>
                        <img src="formula/f101.gif" />
                        (5.1)
                    </p>
                    <p>
                        Зі стану рахунку
                        <img src="formula/s0.gif" />
                        процес із відповідною ймовірністю може перейти в стани
                        <img src="formula/s12h.gif" />, що представляють етапи
                        звернення до файлів <img src="formula/f123h.gif" />, або
                        стан поглинання <img src="formula/sh1.gif" />.
                    </p>
                    <p>
                        Зі станів
                        <img src="formula/s12h.gif" />
                        процес з імовірністю 1 повертається в стан рахунку
                        <img src="formula/s0.gif" />. Досягнувши стану
                        поглинання <img src="formula/sh1.gif" />, процес з
                        імовірністю 1 назавжди залишається там. Переходи між
                        станами
                        <img src="formula/s1s2sh1.gif" />
                        представляються на розміченому графі дугами, на яких
                        позначено ймовірності переходів, відмінні від 1 (Рис.
                        5.3).
                    </p>
                    <div
                        class="d-flex align-items-center flex-column mb-3 mt-3"
                    >
                        <img src="formula/ris53.gif" />
                        <div class="mt-3">Рис. 5.3</div>
                    </div>
                    <p>
                        Значення ймовірностей
                        <img src="formula/p01020h1.gif" />
                        зумовлюють перебіг обчислювального процесу, залежать від
                        параметрів трудомісткості алгоритму і обчислюються таким
                        чином. Трудомісткість алгоритму визначає, зокрема
                        зокрема, середнє число
                        <img src="formula/n1nh.gif" />
                        звернень до файлів
                        <img src="formula/f123h.gif" />. Отже, середнє число
                        переходів зі станів <img src="formula/s0.gif" /> в стани
                        <img src="formula/s12h.gif" />
                        має бути (<img src="formula/n1plnh.gif" />). Один раз
                        процес переходить зі стану
                        <img src="formula/s0.gif" /> в стан поглинання
                        <img src="formula/sh1.gif" />.
                    </p>
                    <p>
                        Таким чином, ОП має виходити зі стану
                        <img src="formula/s0.gif" /> в середньому
                    </p>
                    <div
                        class="d-flex align-items-center flex-column mb-3 mt-3"
                    >
                        <div>
                            <img src="formula/f102.gif" /> <i>разів</i> (5.2)
                        </div>
                    </div>
                    <p>
                        Значення
                        <img src="formula/p0h.gif" />
                        визначає частку переходів у стан
                        <img src="formula/sh.gif" /> по відношенню до всіляких
                        переходів зі стану <img src="formula/s0.gif" /> в стани
                        <img src="formula/s1s2sh1.gif" />. Ця частка дорівнює в
                        середньому <img src="formula/sh.gif" /> (<i>h</i>
                        - номер файлу, до якого звертається процес). Отже,
                    </p>
                    <div
                        class="d-flex align-items-center flex-column mb-3 mt-3"
                    >
                        <div><img src="formula/f103.gif" />, (5.3).</div>
                    </div>
                    <div
                        class="d-flex align-items-center flex-column mb-3 mt-3"
                    >
                        <img src="formula/f104.gif" />
                    </div>
                    <p>
                        Кількість роботи, що виконується на кожному з етапів,
                        характеризується параметрами
                        <img src="formula/teta1th.gif" />
                        алгоритму. Значення
                        <img src="formula/teta.gif" />
                        визначає середню кількість процесорних операцій,
                        виконуваних за одну реалізацію алгоритму, а значення
                        <img src="formula/teta1th.gif" />
                        - середню трудомісткість етапів, що відповідають станам
                        <img src="formula/s12h.gif" />. Середня трудомісткість
                        одного етапу <img src="formula/tet0n.gif" />, де
                        <i>N</i> - середнє число етапів рахунку, що визначається
                        (5.2).
                    </p>
                    <p>
                        Трудомісткість кожного етапу розглянемо як випадкову
                        величину
                        <img src="formula/vh.gif" />Vh з математичним
                        очікуванням <img src="formula/teth.gif" />; закони
                        розподілу випадкових величин
                        <img src="formula/v0vh.gif" />
                        обумовимо особливо.
                    </p>
                    <p>
                        Таким чином, під моделлю обчислювального процесу будемо
                        розуміти ланцюг Маркова з <i>N+2</i> станами, початковим
                        станом
                        <img src="formula/s0.gif" />
                        і матрицею ймовірностей (5.3); під реалізацією
                        обчислювального процесу - випадкову послідовність станів
                        <img src="formula/sss.gif" />, (їхня кількість
                        коливається навколо середнього <i>N</i> для кожної
                        конкретної реалізації), порядок зміни яких визначається
                        в імовірнісному сенсі матрицею ймовірностей переходів.
                    </p>
                    <p>
                        Зі станами
                        <img src="formula/s0.gif" />
                        ,...,
                        <img src="formula/sh.gif" />
                        пов'язана певна кількість роботи, що характеризується
                        значеннями випадкових величин
                        <img src="formula/v0vh.gif" />
                        відповідно.
                    </p>
                    <p>
                        <span
                            >Діаграма обчислювального процесу, породжуваного
                            Марковською моделлю, зображена на рис. 5.3. Значення
                        </span>
                        <i>
                            <span> V<sub>i</sub> </span>
                            
                            <sup>
                                <span> j </span>
                            </sup>
                            <sub>
                                
                            </sub>
                        </i>
                        <span>
                            визначає трудомісткість відповідного етапу і являє
                            собою
                            <i>j-</i>
                            е значення випадкової величини
                            <i>V<sub>i</sub>,</i>
                            математичне очікування якої
                        </span>
                        <i>
                            <span> q </span>
                        </i>
                        <i>
                            <sub>
                                <span> i </span>
                            </sub>
                        </i>
                        <span>
                            . Стан
                            <i>
                                S
                                <sub>3</sub>
                            </i>
                            - поглинання: досягнувши його, процес припиняється.
                        </span>
                    </p>
                    <p>
                        <u>
                            <span> Приклад. </span>
                        </u>
                        <span>
                            Побудуємо Марковську модель обчислювального процесу,
                            породжуваного алгоритмом, трудомісткість якого
                            характеризується такими параметрами:
                        </span>
                        <i>
                            <span> q </span>
                            <span> = 100 </span>
                        </i>
                        <span>
                            млн. операцій;
                            <i>
                                N
                                <sub>1</sub>
                                = 19
                            </i>
                            звернень до файлу
                            <i>F</i>
                            <sub>1</sub>;
                            <i> N<sub>2</sub> = 180 </i>
                            звернень до файлу
                            <i> F<sub>2</sub>; </i>
                        </span>
                        <i>
                            <span> q </span>
                        </i>
                        <i>
                            <sub>
                                <span> 1 </span>
                            </sub>
                        </i>
                        <i>
                            <span> = 2000 </span>
                        </i>
                        <span> байт; </span>
                        <i>
                            <span> q </span>
                            <sub>
                                <span> 2 </span>
                            </sub>
                        </i>
                        <i>
                            <span> = 500</span>
                        </i>
                        <span> байт за звернення до файлу. </span>
                    </p>
                    <p>
                        <span>
                            Відповідно до (5.2) середнє число етапів рахунку при
                            одному прогоні алгоритму
                            <i>N = N<sub>1</sub>+N<sub>2</sub>+1 = 200</i>.
                            Ймовірності переходу процесу зі стану рахунку
                            <i>S<sub>0</sub></i>
                            в состояния
                            <i>S<sub>1</sub>, S<sub>2</sub>, S<sub>3</sub></i
                            ><sub> </sub> визначаються (5.3) і дорівнюють
                            відповідно:</span
                        >
                    </p>
                    <p>
                        <i
                            ><span
                                >P<sub>01</sub>=N<sub>1</sub>/N=19/200=0,095;<span
                                > </span
                                >P<sub>02</sub>=N<sub>2</sub>/N=180/200=0,9;
                            </span></i
                        >
                        <span>
                            <i> P<sub>03</sub>=1/N=0,005. </i>
                        </span>
                    </p>
                    <div
                        class="d-flex align-items-center flex-column mb-3 mt-3"
                    >
                        <img src="formula/ris54.gif" />
                        <div class="mt-3">Рис. 5.4</div>
                    </div>
                    <p>
                        <span
                            >Підставляючи ці значення в матрицю ймовірностей
                            переходів, побачимо, що з імовірністю
                            <i>0,095</i> за етап рахунку відбудеться звернення
                            до файлу <i>F<sub>1</sub></i
                            >, з імовірністю <i>0,9 </i>- звернення до файлу
                            <i>F<sub>2</sub></i>
                            і з імовірністю
                            <i>0,005</i>
                            обчислювальний процес
                            припиниться. Середня трудомісткість етапу рахунку
                            відповідно до
                        </span>
                        <i> <span>q</span></i
                        ><i
                            ><sub><span>0</span></sub></i
                        ><i><span>=</span><span>q</span></i
                        ><i><span>/N=0,5</span></i
                        ><span> млн. операцій. </span>
                    </p>
                    <p>
                        Елементи матриці <i>Р</i>
                        перехідних імовірностей визначаються, як правило,
                        розрахунковим способом під час імітації функціонування
                        операторної схеми алгоритму, під час якої аналізуються
                        значення предикатів в операторах розгалуження алгоритму,
                        а також підраховується кількість операторів
                        введення-виведення. Імітується функціонування схеми для
                        різних варіантів вихідних даних і розмірності задачі.
                    </p>
                    <p>
                        Коли матрицю <i>Р</i>
                        аналітичним способом визначити неможливо, вдаються до
                        статистичних випробувань програми, за результатами яких
                        визначають елементи матриці
                        <i>Р</i> і всі необхідні характеристики для моделі
                        досліджуваної програми:
                    </p>
                    <ul>
                        <li>
                            <span
                                >обчислювальну трудомісткість одиночного запиту
                                на ресурс процесора </span
                            ><i
                                ><span>q</span><sub><span>0</span></sub></i
                            ><i><span>;</span></i>
                        </li>
                        <li>
                            <span
                                >інтенсивність потоку заявок на ресурс процесора </span
                            ><i><span>l</span></i
                            ><i
                                ><sub><span>0</span></sub></i
                            ><span>; </span>
                        </li>
                        <li>
                            <span
                                >трудомісткість одиночного запиту до системи
                                введення-виведення на пересилання порцій
                                інформації між фіксованим зовнішнім
                                запам'ятовуючим пристроєм
                                (ЗЗП<sub>&#1110;</sub>) прямого доступу та
                                оперативною пам'яттю </span
                            ><i><span>q</span></i
                            ><i
                                ><sub><span>I</span></sub></i
                            ><i><span>;</span></i
                            >
                        </li>
                        <li>
                            <span
                                >інтенсивність потоку заявок на ресурс системи
                                введення-виведення </span
                            ><i
                                ><span>l</span
                                ><sub><span>&#1110;</span></sub></i
                            ><span>
                                при обмінах інформацією між ЗЗП<sub
                                    >&#1110;</sub
                                >
                                і оперативною пам'яттю;
                            </span>
                        </li>
                        <li>
                            <span
                                >середню тривалість пошуку однієї адреси для
                                інформації, яку зберігає досліджувана програма
                                на ЗЗП<sub>i</sub> </span
                            ><i
                                ><span>t</span><sub><span>i</span></sub></i
                            ><span> ; </span>
                        </li>
                        <li>
                            <span
                                >інтенсивність потоку запиту від програми до
                                контрольного ЗЗП на пошук адрес </span
                            ><i
                                ><span>l</span
                                ><sub><span>&#1110;</span></sub></i
                            ><i><span> ;</span></i
                            >
                        </li>
                        <li>
                            <span
                                >трудомісткість одиночного запиту на ресурс
                                розпізнавання або відображення інформації до
                                <i>j</i>-му устройству ввода-вывода (ПВВ<sub
                                    >j</sub
                                >
                                ) ;
                                <i>W<sub>j</sub></i>
                                ;
                            </span>
                        </li>
                        <li>
                            <span
                                >інтенсивність потоку заявок до ресурсу ПВВ<sub
                                    >j</sub
                                > </span
                            ><i
                                ><span>l</span><sub><span>j</span></sub></i
                            ><span> ; </span>
                        </li>
                        <li>
                            <span
                                >середню тривалість пошуку однієї адреси для
                                інформації на ПВВ<sub>j</sub> </span
                            ><i><span>t</span></i
                            ><sub><span>j</span></sub
                            ><span>; </span>
                        </li>
                        <li>
                            <span
                                >інтенсивність потоку запитів до контролера
                                ПВВ<sub>j</sub> на пошук адрес </span
                            ><i
                                ><span>l</span><sub><span>j</span></sub></i
                            ><i><span> ;</span></i
                            >
                        </li>
                        <li>
                            <span
                                >трудомісткість одиночного запиту до системи
                                введення-виведення на пересилання порції
                                інформації між ПВВ<sub>j</sub> і оперативною
                                пам'яттю <i>W<sub>j</sub> </i>;
                            </span>
                        </li>
                        <li>
                            <span
                                >інтенсивність заявок до системи
                                введення-виведення при обміні інформацією між
                                ПВВ<sub>j</sub> и оперативною пам'яттю </span
                            ><i><span>l</span></i
                            ><i
                                ><sub><span>j</span></sub></i
                            ><span>.</span>
                        </li>
                    </ul>
                    <p>
                        <a name="theory_3_1">
                            <h3>
                                3.1. Аналітичний спосіб визначення характеристик моделі програми
                            </h3>
                        </a>
                    </p>
                    <p>
                        Стосовно до завдань визначення характеристик оператори
                        алгоритму будемо поділяти на функціональні, переходу та
                        введення-виведення.
                    </p>
                    <p>
                        Функціональний оператор задає перетворення на множині
                        даних, тобто деяку сукупність обчислювальних операцій;
                    </p>
                    <p>
                        Оператор переходу - порядок обчислень значень предикатів
                        і правило вибору одного з можливих шляхів розвитку
                        обчислювального процесу, що відповідає поточним
                        значенням даних, відносини між якими представляються
                        предикатами. Функціональні оператори та оператори
                        переходу задають сукупності обчислювальних операцій і
                        відносин над даними і належать до одного класу
                        операторів, які називаються основними операторами;
                    </p>

                    <p></p>
                    <p>
                        Оператор введення-виведення - звернення до певного файлу
                        з метою передачі деякої кількості інформації.
                    </p>
                    <p>
                        Сукупність операторів і зв'язків між ними найбільш
                        наочно представляють графом алгоритму, який будується як
                        композиція вершин, що відповідають операторам алгоритму,
                        і дуг, що відображають зв'язки між операторами.
                        Виділяють вершини початкові, кінцеві, операторні.
                        Початкова вершина не має жодного входу і має тільки один
                        вихід. Така вершина визначає початок алгоритму. Кінцева
                        вершина має щонайменше один вхід і жодного виходу;
                        визначає кінець алгоритму. Операторна вершина відповідає
                        основному оператору або оператору введення-виведення.
                    </p>
                    <p>
                        Вершина, що представляє функціональний оператор або
                        оператор введення-виведення, може мати будь-яку, не
                        меншу за одиницю, число входів і тільки один вихід.
                        Вершина, що представляє оператор переходу, може мати
                        будь-яке, не менше одиниці число входів і не менше двох
                        несумісних виходів. У будь-якій ситуації оператор
                        переходу визначає один і тільки один вихід із вершини,
                        що представляє його.
                    </p>
                    <p>
                        Граф алгоритму є коректним, якщо виконуються такі умови:
                    </p>
                    <ol>
                        <li>
                            Є тільки одна початкова і тільки одна кінцева
                            вершини;
                        </li>
                        <li>
                            Для кожної вершини, крім початкової, існує
                            щонайменше один шлях, який веде в цю вершину з
                            початкової;
                        </li>
                        <li>
                            З кожної вершини, крім кінцевої, існує щонайменше
                            один шлях, який веде з цієї вершини в кінцеву;
                        </li>
                        <li>
                            Активний вихід із будь-якої вершини повинен вести
                            тільки до однієї вершини графа;
                        </li>
                        <li>
                            За будь-яких значень логічних умов (предикатів)
                            існує шлях із початкової вершини в кінцеву, причому
                            будь-якому фіксованому набору значень умов
                            відповідає один такий шлях.
                        </li>
                    </ol>
                    <p>Приклад графа алгоритму показано на рис. 5.5.</p>
                    <div
                        class="d-flex align-items-center flex-column mb-3 mt-3"
                    >
                        <img src="formula/ris55.gif" />
                        <div class="mt-3">Рис. 5.5.</div>
                    </div>
                    <p>
                        Домовимося вершини графа позначити номерами
                        <i>0, 1, . . . К:</i>
                    </p>
                    <p>
                        <i>0</i>
                        відповідає початковій вершині графа;
                    </p>
                    <p>
                        <i><span>К</span></i
                        ><span> - кінцевій вершині; </span>
                    </p>
                    <p>
                        <i><span>1, . . . К-1</span></i
                        ><span> ідентифікує оператори алгоритму. </span>
                    </p>
                    <p>
                        У програмуванні графи алгоритмів зображуються з
                        використанням використанням набору фігур, що позначають
                        тип оператора, і називаються схемами алгоритмів
                        (програм).
                    </p>
                    <p>
                        Граф виконує структуру алгоритму, визначаючи безліч
                        операторів
                        <img src="formula/theory1.gif" />
                        і дуг
                        <img src="formula/theory2.gif" />
                        і
                        <img src="formula/theory3.gif" />, що пов'язують
                        оператори.
                    </p>
                    <p>
                        <span
                            >Для оцінки трудомісткості алгоритму необхідно,
                            по-перше, розбити множину операторів на класи
                            основних операторів
                            <span> <img src="formula/theory4.gif" /></span>;
                            оператор введення-виведення
                            <span> <img src="formula/theory5.gif" /></span>
                            кожен із цих операторів задає звернення
                            до одного й того самого ж файлу
                            <i>F<sub>h</sub>.</i>
                        </span>
                    </p>
                    <p>
                        По-друге, для кожного основного оператора V<sub>
                            <span>a</span></sub
                        ><span>
                            необхідно визначити середню кількість операцій
                            <i>К</i></span
                        ><i
                            ><sub><span>a</span></sub
                            ><span>,</span></i
                        ><span>
                            що складають оператор, і для кожного оператора
                            введення-виведення
                            <i>V</i></span
                        ><i
                            ><sub><span>b</span></sub></i
                        ><span>
                            - середню кількість інформації
                            <i>l</i></span
                        ><i
                            ><sub><span>b</span></sub
                            ><span>,</span></i
                        ><span>
                            що передається під час виконання оператора.
                        </span>
                    </p>
                    <p>
                        <span
                            >По-третє, переходи між операторами
                            <i>V<sub>i</sub> </i>
                            і
                            <i> V<sub>j</sub></i>
                            слід розглядати як випадкові події та
                            характеризувати їх імовірностями
                            <i>P<sub>ij</sub></i
                            >, тобто кожна дуга <i>/i, j/</i>
                            графа алгоритму має бути позначена ймовірністю
                            переходу
                            <i>P<sub>ij</sub></i>
                            , з якою перехід із вершини
                            <i>V<sub>1</sub></i>
                            виконується саме по цій дузі, тобто до вершини
                            <i>V<sub>j</sub></i
                            >.
                        </span>
                    </p>
                    <p>
                        <span
                            >Оскільки обчислювальний процес не може
                            призупинитися у вершині
                            <i>V<sub>i</sub></i>
                            то з імовірністю 1 відбудеться перехід до будь-якої
                            вершини графа алгоритму. З урахуванням цього,
                            ймовірності переходів повинні відповідати умові
                        </span>
                    </p>
                    <div
                        class="d-flex align-items-center flex-column mb-3 mt-3"
                    >
                        <i
                            ><span> <img src="formula/theory6.gif" /></span>
                            <span> <img src="formula/theory7.gif" /></span>
                        </i>
                    </div>
                    <p>
                        <span
                            >Значення
                            <i>P<sub>ij</sub></i>
                            визначаються таким чином. Якщо за оператором
                            неодмінно виконується оператор
                            <i>j, P<sub>ij</sub>=1</i>. Якщо перехід
                            здійснюється через умовний оператор, тобто
                            обчислюється предикат і залежно від від його
                            значення визначається траса алгоритму, то значення
                            P<sub>ij</sub> визначаються ймовірностями значень
                            предиката. Наприклад, нехай оператор 2 (рис. 5.5)
                            породжує перехід до оператора 3 за умови від'ємного
                            значення деякої змінної
                            <i>Х</i>
                            і до оператору 4 при позитивному значенні
                            <i>Х</i>. Якщо відомо, що величина
                            <i>Х</i>
                            рівномірно розподілена в діапазоні
                            <i>(-1, +3)</i>, то з імовірністю
                            <i>0,25</i>
                            її знак від'ємний і з імовірністю
                            <i>0,75</i>
                            додатній. З цього випливає, що перехід до оператора
                            3 відбувається з імовірністю
                            <i>Р<sub>23</sub>=0,25</i>
                            і перехід до оператора 4 - з імовірністю
                            <i>Р<sub>24</sub>=0,75. </i></span
                        ><i></i>
                    </p>
                    <p>
                        <a name="theory_3_2">
                            <h3>
                                3.2. Обчислення характеристик трудомісткості
                            </h3>
                        </a>
                    </p>
                    <p>
                        <span
                            >Нехай
                            <i>n<sub>1</sub>, ..., n<sub>K-1</sub></i>
                            - середнє число звернень до операторів
                            <i>V<sub>1</sub>, ..., V<sub>K-1</sub></i>
                            за один прогін алгоритму. Середнє число операцій,
                            виконуваних під час одного прогону алгоритму,
                        </span>
                    </p>
                    <p>
                        <span
                            ><i
                                ><span> <img src="formula/theory8.gif" /></span>
                                ,</i
                            >(5.4)
                        </span>
                    </p>
                    <p>
                        <span
                            >середнє число звернень до файлу F<sub>h</sub>
                        </span>
                    </p>
                    <p>
                        <span
                            ><span> <img src="formula/theory9.gif" /></span>
                            (5.5)
                        </span>
                    </p>
                    <p>
                        <span
                            >середня кількість інформації, що передається під
                            час одного звернення до файлу F<sub>h</sub>,
                        </span>
                    </p>
                    <p>
                        <span
                            ><span> <img src="formula/theory10.gif" /></span>
                            (5.6)
                        </span>
                    </p>
                    <p>
                        <span>
                            У (5.4-5.6) підсумовування виконується за всіма
                            вершинами, що належать до класу основних операторів
                            <i>S<sub>0</sub></i>
                            або класу операторів введення-виведення
                            <i>S<sub>h</sub>,</i>
                            які звертаються до файлу
                            <i>F<sub>h</sub></i
                            >. Із цих формул очевидно, що для оцінки
                            трудомісткості алгоритму насамперед слід визначити
                            середнє число звернень
                            <i>n<sub>1</sub>, ..., n<sub>K-1</sub></i
                            >
                            до операторів. Це можна зробити мережевим методом,
                            трудомісткість якого невисока і не виникає
                            необхідності в автоматизації обчислень. Суть
                            мережевого підходу полягає у виділенні шляхів на
                            графі алгоритму, що відповідають мінімальній,
                            середній і максимальній трудомісткості послідовності
                            операторів. Ці шляхи можуть бути виділені тільки на
                            графах, що не містять циклів.
                        </span>
                    </p>
                    <p>
                        <a name="theory_3_3">
                            <h3>
                                3.3. Оцінка середньої трудомісткості алгоритмів
                            </h3>
                        </a>
                    </p>
                    <p>
                        <span
                            >Представимо алгоритм у вигляді розміченого графа,
                            що складається з
                            <i>К</i>
                            операторних вершин і такого, що має єдину кінцеву
                            вершину з
                            <i>номером К=К+1</i>; дуги графа позначені
                            ймовірностями переходів <i>P<sub>ij</sub></i
                            >.
                        </span>
                    </p>
                    <p>
                        <span
                            >Кожній вершині графа поставлено у відповідність
                            середнє значення трудомісткості
                            <i>К<sub>i</sub></i>
                            або l<i><sub>j</sub></i
                            >. З урахуванням (5.4-5.6) завдання оцінки
                            трудомісткості алгоритму зводиться до визначення
                            середнього числа
                            <i
                                >n<sub>1</sub>, n<sub>2</sub>, ..., n<sub
                                    >К</sub
                                ></i
                            >
                            звернень до операторів за один прогін алгоритму.
                        </span>
                    </p>
                    <p>
                        <span
                            >Розглянемо методику обчислення значень
                            <i
                                >n<sub>1</sub>, n<sub>2</sub>, ..., n<sub
                                    >К</sub
                                ></i
                            >
                            для алгоритму, що не містить циклів.
                        </span>
                    </p>
                    <p>
                        <span>
                            Для застосування мережевого методу вершини графа
                            повинні бути пронумеровані так, щоб будь-яка вершина
                            мала номер, більший за будь-який номер попередніх їй
                            вершин : початковій вершині присвоюється номер
                            <i>0</i>; черговий номер <i>i=1,2..</i>.
                            присвоюється вершині, у яку входять дуги від уже
                            пронумерованих вершин із номерами, меншими за
                            <i>i</i>. При цьому будь-яким двом вершинам повинні
                            відповідати різні номери. Кінцева вершина графа
                            повинна мати максимальний номер <i>К</i>.
                        </span>
                    </p>
                    <p>
                        Приклад коректної нумерації вершин графа показано на
                        рис. 5.6.
                    </p>
                    <div
                        class="d-flex align-items-center flex-column mb-3 mt-3"
                    >
                        <img src="formula/ris56.gif" />
                        <div class="mt-3">Рис. 5.6</div>
                    </div>
                    <p>
                        <span
                            >Оскільки граф не містить циклів, то під час прогону
                            алгоритму вершина 1 буде виконана точно один раз,
                            т.е<i>. n<sub>1</sub>=1</i>. Середнє число
                            потрапляння ОП у вершину i визначається виразом
                        </span>
                    </p>
                    <p>
                        <span
                            ><span> <img src="formula/prob1.gif" /></span>
                            ,
                            (5.7)
                        </span>
                    </p>
                    <p>
                        <span
                            >де
                            <i>P<sub>ij</sub></i>
                            - ймовірність переходу з вершини
                            <i>j</i>
                            у вершину
                            <i>i.</i>
                        </span>
                    </p>
                    <p>
                        <span
                            >Формула (5.7) пояснюється так: процес<span
                            > </span>потрапляє в стан
                            <i>S<sub>i</sub></i>
                            только из других состояний
                            <span> <img src="formula/prob2.gif" /></span>
                            
                            з імовірностями
                            <i>P<sub>ij</sub></i
                            >. Якщо процес перебував у стані
                            <i><img src="formula/jnj.gif" /></i></span
                        ><span>
                            разів і
                            <i><img src="formula/pijner0.gif" /></i></span
                        ><span
                            >, то процес із цього стану потрапить у стан
                            <i>i</i>
                            в середньому
                            <i><img src="formula/pijnj.gif" /></i></span
                        ><span>
                            разів. Підсумовуванням значень
                            <i><img src="formula/pijnj.gif" /> </i></span
                        ><span>
                            по всім
                            <i>j</i>
                            знаходиться число потраплянь процесу в стан
                            <i>i</i>
                            з усіх інших станів
                            <i>j.</i>
                        </span>
                    </p>
                    <p>
                        <span
                            >При встановленому порядку нумерації вершин на
                            момент обчислення
                            <i>n<sub>i</sub></i>
                            значення
                            <i>n<sub>1</sub>, ..., n<sub>i-1</sub></i>
                            вже визначені. Тому обчислення значення
                            <i>n<sub>i</sub> </i>зводиться до підсумовування
                            добутків, причому, оскільки
                            <i>P<sub>ji</sub>=0</i>
                            для всіх j<img src="formula/bol1.gif" /></span
                        ><span
                            >i, то підсумовування слід проводити для
                            <i>j&lt;i.</i>
                        </span>
                    </p>
                    <p>
                        <b> Приклад </b>
                    </p>
                    <p>
                        <span>
                            Визначимо середнє число звернень
                            <i>n<sub>1</sub>, ..., n<sub>К</sub></i>
                            до операторів алгоритму, зображеного на графі рис.
                            5.6. Застосувавши (5.7), отримаємо</span
                        >
                    </p>
                    <p>
                        <img src="formula/f105.gif" /><i></i
                        >
                    </p>
                    <p>
                        <span
                            >Розглянемо алгоритм, що містить цикли (рис. 5.7).
                            Застосувати викладену методику для визначення
                            <i>n<sub>1</sub>, ..., n<sub>К</sub></i>
                            неможливо, тому вивчимо прийоми виключення циклів.
                            Для спрощення опису прийомів приймемо, що алгоритм
                            складається з однотипних операторів, наприклад
                            тільки з основних операторів. Розділимо цикли за
                            рангами. До рангу 1 належать цикли, що не містять
                            усередині себе жодного циклу, до рангу 2 - цикли,
                            усередині яких є цикли рангу не вище за перший і т.
                            д. Наприклад, алгоритм, зображений на рис. 5.7,
                            містить два цикли С<sub>1</sub> і С<sub>2</sub>
                            рангу 1 і один цикл С<sub>3</sub> рангу 2.
                        </span>
                    </p>
                    <p>
                        <span
                            >Сукупність операторів, що входять у цикл, і дуг, що
                            їх зв'язують, за винятком дуги, яка замикає цикл,
                            називають тілом циклу. Тіло циклу рангу 1 - граф без
                            циклів. Застосовуючи до цього графа описану
                            методику, можна визначити значення
                            <i>n<sub>i</sub></i>
                            для кожного з операторів, що належать тілу циклу,
                            отже, трудомісткість тіла циклу
                            <i>С</i> равна <img src="formula/f106.gif" />. Тут
                            підсумовування проводиться по всіх вершинах <i>V</i
                            ><sub>j</sub>, що містяться в циклі <i>С</i>.
                        </span>
                    </p>
                    <p>
                        <span
                            >Нехай відоме середнє число повторень циклу
                            <i>n<sub>C</sub></i
                            >, що дорівнює числу виконань циклу під час одного
                            прогону алгоритму. Якщо ймовірність переходу по
                            дузі, що замикає цикл, дорівнює
                            <i
                                >P<sub>kl</sub> , то
                                <img src="formula/f107.gif" /></i></span
                        >,<span>
                            звідки
                            <i>n<sub>C</sub>=1/(1-P<sub>kl</sub>)</i>.
                        </span>
                    </p>
                    <p>Середня трудомісткість циклу</p>
                    <p>
                        <span>
                            <img src="formula/f108.gif" />
                        </span>
                    </p>
                    <p>
                        <span
                            >і цикл можна замінити оператором із трудомісткістю
                            <i>К<sub>С</sub></i
                            >. Застосовуючи зазначену процедуру заміни циклів
                            операторами до всіх циклів рангу 1, потім до циклів
                            рангу 2 і т.д., зрештою прийдемо до графа без
                            циклів, трудомісткість якого знаходиться зазначеним
                            способом.
                        </span>
                    </p>
                    <p>
                        <b> Приклад </b>
                    </p>
                    <p>
                        <span>
                            Визначимо трудомісткість алгоритму, заданого графом,
                            зображеним на рис. 5.7. Припустимо, що
                            трудомісткість усіх операторів однакова і дорівнює
                            1. Середнє число повторень циклів
                            <i>С<sub>1</sub>, С<sub>2</sub></i>
                            і
                            <i>С<sub>3</sub></i>
                            визначається з імовірностей переходів, зазначених на
                            рис. 5.7, значеннями
                            <i
                                >n<sub>C1</sub>=5, n<sub>C2</sub>=20 и
                                n<sub>C3</sub>=10</i
                            >. Виділимо тіла циклів
                            <i>С<sub>1</sub> и С<sub>2</sub></i>
                            рангу 1. Їхню структуру зображено на рис. 5.8.</span
                        >
                    </p>
                    <div
                        class="d-flex align-items-center flex-column mb-3 mt-3"
                    >
                        <img src="formula/ris57.gif" />
                        <div class="mt-3">Рис. 5.7</div>
                    </div>
                    <p>
                        Застосовуючи описану методику до цих графів, визначаємо
                        середню трудомісткість
                        <span> <img src="formula/the1.gif" /></span>
                        і
                        <span> <img src="formula/the2.gif" /></span>
                        виконання тіл цих циклів:
                    </p>
                    <p>
                        <img src="formula/f109.gif" />
                    </p>
                    <p>
                        Середня трудомісткість циклів
                        <i>С<sub>1</sub></i>
                        и
                        <i>С<sub>2</sub></i>
                        обчислюється множенням отриманих значень на середнє
                        число повторень цих циклів:
                        <i>
                            <span> <img src="formula/the1.gif" /></span>
                            = 17,5</i
                        >
                        и
                        <i
                            ><span> <img src="formula/the2.gif" /></span> =
                            64</i
                        >
                        операцій.
                    </p>
                    <p>
                        <span
                            >Заміняючи вграфі (рис. 5.7) цикли
                            <i>С<sub>1</sub></i>
                            и
                            <i>С<sub>2</sub></i>
                            операторами
                            <i>С<sub>1</sub></i>
                            и
                            <i>С<sub>2</sub></i>
                            з трудомісткістю
                            <span> <img src="formula/the1.gif" /></span>
                            і
                            <span> <img src="formula/the2.gif" /></span>
                            , отримаємо граф, вигляд якого показано на рис. 5.9.
                            Тіло циклу
                            <i>С<sub>3</sub></i>
                            визначається наступним чином:</span
                        >
                    </p>
                    <p>
                        <img src="formula/f110.gif" />
                    </p>
                    <p>
                        <span
                            >З урахуванням числа n<sub>C3</sub> повторень циклу
                            трудомісткість циклу становитиме
                            <i>К<sub>С3</sub>=474</i>
                            операцій. Замінивши цикл
                            <i>С<sub>3</sub> </i>оператором
                            <i>С<sub>3</sub></i>
                            з трудомісткістю
                            <i>К<sub>С3</sub>,</i>
                            отримаємо граф (рис. 5.10).
                        </span>
                    </p>
                    <p>Трудомісткість алгоритму, представленого цим графом:</p>
                    <p>
                        <i
                            ><span>q</span
                            ><span>
                                = К<sub>1</sub>+К<sub>С3</sub>+К<sub>13</sub> =
                                1+474+1 = 476</span
                            ></i
                        ><span> операцій. </span>
                    </p>
                    <div
                        class="d-flex align-items-center flex-column mb-3 mt-3"
                    >
                        <img src="formula/ris58.gif" />
                        <div class="mt-3">Рис.5.8.</div>
                    </div>
                    <div
                        class="d-flex align-items-center flex-column mb-3 mt-3"
                    >
                        <img src="formula/ris59.gif" />
                        <div class="mt-3">Рис. 5.9</div>
                    </div>
                    <div
                        class="d-flex align-items-center flex-column mb-3 mt-3"
                    >
                        <img src="formula/ris510.gif" />
                        <div class="mt-3">Рис. 5.10</div>
                    </div>
                    <p>
                        <a name="theory_3_4">
                            <h3>
                                3.4. Оцінка мінімальної та максимальної трудомісткості алгоритму
                            </h3>
                        </a>
                    </p>
                    <p>
                        <span
                            >Мінімально і максимально можливі значення
                            трудомісткості на момент закінчення виконання
                            оператора
                            <i>V<sub>i</sub></i>
                            позначимо відповідно через
                            <i>А</i><sub>i</sub> і <i>B<sub>i</sub></i
                            >. Маємо <i>А<sub>0</sub>=0 и В<sub>0</sub>=0</i>.
                            Тоді для решти вершин із номерами
                            <i>i=1,k </i></span
                        >
                    </p>
                    <p>
                        <span>
                            <img src="formula/theo7.gif" />
                            , (5.8)
                        </span>
                    </p>
                    <p>
                        <span
                            ><span> <img src="formula/theo8.gif" /></span>
                            ,(5.9)
                        </span>
                    </p>
                    <p>
                        <span
                            >де <i>(j,i)</i> - дуга, що виходить із вершини
                            <i>j </i>
                            і входить у вершину
                            <i>i; D</i>
                            - множина дуг графа програми;
                            <i>min(A<sub>i</sub>) и max(B<sub>j</sub>)</i>
                            визначаються стосовно всіх вершин
                            <i>j</i>, з яких виходять дуги, що входять у вершину
                            <i>i</i>; значення
                            <i>K<sub>i min</sub></i>
                            и
                            <i>K<sub>i max</sub></i>
                            характеризують мінімальну і максимальну
                            трудомісткість оператора
                            <i>V<sub>i</sub></i
                            >. Для кінцевої вершини <i>К</i> графа обчислюються
                            значення
                        </span>
                    </p>
                    <p>
                        <i
                            ><span
                                >A<sub>K</sub>=min(A<sub>j</sub>);<span
                                > </span>B<sub>K</sub>=max(B<sub>j</sub>),
                            </span></i
                        >
                    </p>
                    <p>
                        <i>(j,k)</i>
                        <i>
                            <img src="formula/e.gif" />
                            D (j,k)
                            <img src="formula/e.gif" />
                            D
                        </i>
                    </p>
                    <p>
                        <span
                            >що характеризують мінімальну та максимальну
                            трудомісткість алгоритму.
                        </span>
                    </p>
                    <p>
                        <b> Приклад </b>
                    </p>
                    <p>
                        Визначимо мінімальну та максимальну трудомісткість
                        алгоритму, зображеного на рис. 5.6. Припустимо, що
                        трудомісткість кожного оператора постійна і дорівнює 1.
                        Нумерація вершин на графі рис. 5.6 відповідає
                        розглянутому правилу.
                    </p>
                    <p>Застосовуючи послідовно (5.8) и (5.9), отримаємо:</p>
                    <p>
                        <i
                            ><span>А</span><sub><span>0</span></sub
                            ><span>=0B<sub>0</sub>=0 </span></i
                        >
                    </p>
                    <p>
                        <i
                            ><span>А</span><sub><span>1</span></sub
                            ><span
                                >=min(A<sub>0</sub>)+1=1<span
                                > </span>B<sub>1</sub>=max(B<sub>0</sub>)+1=1
                            </span></i
                        >
                    </p>
                    <p>
                        <i
                            ><span>А</span><sub><span>2</span></sub
                            ><span
                                >=min(A<sub>1</sub>)+1=2<span
                                > </span>B<sub>2</sub>=max(B<sub>1</sub>)+1=2
                            </span></i
                        >
                    </p>
                    <p>
                        <i
                            ><span>А</span><sub><span>3</span></sub
                            ><span
                                >=min(A<sub>2</sub>)+1=3<span
                                > </span>B<sub>3</sub>=max(B<sub>2</sub>)+1=3
                            </span></i
                        >
                    </p>
                    <p>
                        <i
                            ><span>А</span><sub><span>4</span></sub
                            ><span
                                >=min(A<sub>2</sub>)+1=3<span
                                > </span>B<sub>4</sub>=max(B<sub>2</sub>)+1=3
                            </span></i
                        >
                    </p>
                    <p>
                        <i
                            ><span>А</span><sub><span>5</span></sub
                            ><span
                                >=min(A<sub>3</sub>)+1=4<span
                                > </span>B<sub>5</sub>=max(B<sub>3</sub>)+1=4
                            </span></i
                        >
                    </p>
                    <p>
                        <i
                            ><span>А</span><sub><span>6</span></sub
                            ><span
                                >=min(A<sub>2</sub>,A<sub>3</sub>,A<sub>4</sub>)+1=3<span
                                ></span
                                >B<sub>2</sub>=max(B<sub>2</sub>,B<sub>3</sub>,B<sub>4</sub>)+1=4
                            </span></i
                        >
                    </p>
                    <p>
                        <i
                            ><span>А</span><sub><span>7</span></sub
                            ><span
                                >=min(A<sub>4</sub>)+1=4<span
                                ></span>B<sub>7</sub>=max(B<sub>4</sub>)+1=4
                            </span></i
                        >
                    </p>
                    <p>
                        <i
                            ><span>А</span><sub><span>8</span></sub
                            ><span
                                >=min(A<sub>5</sub>,A<sub>6</sub>)+1=4<span
                                ></span
                                >B<sub>8</sub>=max(B<sub>5</sub>,B<sub>6</sub>)+1=5
                            </span></i
                        >
                    </p>
                    <p>
                        <i
                            ><span>А</span><sub><span>9</span></sub
                            ><span
                                >=min(A<sub>7</sub>,A<sub>8</sub>)+1=5<span
                                ></span
                                >B<sub>9</sub>=max(B<sub>7</sub>,B<sub>8</sub>)+1=6
                            </span></i
                        >
                    </p>
                    <p>
                        <i
                            ><span>А</span><sub><span>10</span></sub
                            ><span
                                >=min(A<sub>5</sub>,A<sub>9</sub>)+1=5<span
                                ></span
                                >B<sub>10</sub>=max(B<sub>5</sub>,B<sub>9</sub>)+1=7
                            </span></i
                        >
                    </p>
                    <p>
                        <i
                            ><span>А</span><sub><span>K</span></sub
                            ><span
                                >=min(A<sub>10</sub>)=5<span
                                > </span>B<sub>K</sub>=max(B<sub>10</sub>)+1=7
                            </span></i
                        ><i></i>
                    </p>
                    <p>
                        <span
                            >Таким чином, мінімальна трудомісткість алгоритму
                            <i>А<sub>К</sub></i>
                            дорівнює п'яти, мінімальна
                            <i>В<sub>К</sub></i>
                            - семи операціям.
                        </span>
                    </p>
                    <p>
                        <span
                            >Мінімальна і максимальна трудомісткість алгоритмів,
                            що містять цикли, знаходиться за аналогією з методом
                            визначення середньої трудомісткості алгоритмів із
                            циклами. При цьому виокремлюються цикли рангу 1.
                            Знаходяться <i>А</i> и
                            <i>В</i>
                            трудомісткості тіла циклу. Мінімальна і максимальна
                            трудомісткість циклу визначається значеннями
                            <span> <img src="formula/theo9.gif" /></span>
                            и
                            <span> <img src="formula/theo10.gif" /></span>
                            , де
                            <i>n<sub>min</sub></i>
                            и
                            <i>n<sub>max</sub></i>
                            - мінімальне і максимальне число повторень циклу.
                            Потім цикл замінюється оператором з трудомісткістю
                            <span> <img src="formula/theo11.gif" /></span>
                            и
                            <span> <img src="formula/theo12.gif" /></span>
                            і знову застосовується процедура виключення циклів.
                            Процес повторюється доти, доки граф алгоритму не
                            буде перетворено до форми без циклів.
                        </span>
                    </p>
                    <p>
                        <span
                            >Мінімальна і максимальна кількість повторень циклів
                            <i>n<sub>min</sub></i>
                            и
                            <i>n<sub>max</sub></i>
                            має бути задано у вхідних даних розв'язання
                            завдання.</span
                        >
                    </p>
                    <p>
                        <a name="theory_3_5">
                            <h3>3.5. Методика моделювання ресурсів ОС</h3>
                        </a>
                    </p>
                    <p>
                        <b>Моделі пристроїв-ресурсів і способи їх опису</b>
                    </p>
                    <p>
                        <b>Модель процесора й оперативної пам'яті</b>
                    </p>
                    <p>
                        <span>
                            Підсистема "процесор - оперативна пам'ять"
                            розглядається як одноканальна СМО (рис. 5.11),
                            обслуговуючим каналом (приладом) у якій є процесор
                            <i>Пр.</i>
                            Під час роботи ВС у мультипрограмному режимі в
                            оперативній пам'яті
                            <i>ОП</i>
                            розміщено кілька програм
                            <i
                                >П<sub>1</sub>, П<sub>2</sub>, ..., П<sub
                                    >М</sub
                                ></i
                            >. Одні програми перебувають у стані готовності до
                            виконання, інші - у стані очікування деяких подій,
                            наприклад завершення операцій введення-виведення.
                        </span>
                    </p>
                    <p>
                        <span
                            >Сукупності готових до виконання програм відповідає
                            черга
                            <i>0</i>
                            заявок в СМО (рис. 5.11). Програма з черги, що
                            отримала доступ до процесора
                            <i>Пр</i>, переходити в стан рахунку. Середній час
                            безперервного рахунку програми визначає середню
                            тривалість
                            <i>V</i>
                            процесу обслуговування заявки в СМО. Процес рахунку,
                            тобто обслуговування програми процесором,
                            припиняється в момент, коли програма звертається до
                            системи введення-виведення, тобто до зовнішнього
                            пристрою (ЗЗП) або пристрою введення-виведення. При
                            цьому вважається, що заявку на рахунок обслужено і
                            вона залишає систему "процесор - оперативна
                            пам'ять". Обслуговування цієї заявки, тобто цієї
                            програми, буде продовжено іншим пристроєм ОС.
                            Інтенсивність
                        </span>
                        <i>
                            <span>l</span>
                        </i>
                        <span>
                            надходження заявок у СМО визначається сумарною
                            інтенсивністю поповнення списку готових до виконання
                            програм, як за рахунок надходження нових програм,
                            так і за рахунок програм, для яких завершено
                            введення-виведення. Неодмінна умова готовності
                            програми - наявність її в оперативній пам'яті.
                        </span>
                        
                    </p>
                    <p>
                        <a name="theory_3_6">
                            <h3>3.6. Модель мультиплексного каналу</h3>
                        </a>
                    </p>
                    <p>
                        <span>
                            Мультиплексний канал (МК) забезпечує паралельну і
                            незалежну роботу підключених до нього пристроїв
                            введення-виведення УВВ різних типів (рис. 5.12, а):
                            пристроїв введення з перфокарт ПВП, друкувальних
                            пристроїв ДП, пультової друкарської машинки ПДМ
                            тощо. Тому кожен із цих пристроїв має розглядатися
                            як окремий канал СМО. Кілька однотипних пристроїв
                            введення-виведення можуть розглядатися як
                            багатоканальна СМО з однаковим середнім часом
                            обслуговування заявок у кожному з каналів.
                        </span>
                    </p>
                    <p>
                        <span
                            >МК із під'єднаними до нього пристроями
                            введення-виведення подається у вигляді СМО (рис.
                            5.12, б): система
                            <i>S1</i>
                            відображає роботу
                            <i>К1</i>
                            однотипних пристроїв введення-виведення ПВВ; у
                            кожному з яких заявки на введення-виведення
                            обслуговуються в середньому за час
                            <i>V<sub>1</sub></i
                            >.
                        </span>
                    </p>
                    <p>
                        Інтенсивність потоку, що входить у цю систему, дорівнює
                        частці
                        <i>р<sub>1</sub></i>
                        від інтенсивності
                        <i> <span>l</span></i
                        ><span>
                            усіх заявок, що обслуговуються МК. За аналогією,
                            система
                            <i>S<sub>n</sub></i>
                            відображає роботу інших
                            <i>K<sub>n</sub></i>
                            пристроїв введення-виведення УВВ із середнім часом
                            обслуговування заявок
                            <i>V<sub>n</sub></i>
                            та інтенсивністю вхідного потоку
                            <img src="formula/pnlamda.gif" /></span
                        ><span
                            >. Очевидно, що має виконуватися рівність<span
                            > </span>
                        </span>
                    </p>
                    <p>
                        <img src="formula/sumver.gif" />
                    </p>
                    <p>
                        <a name="theory_3_7">
                            <h3>3.7. Моделі селекторних каналів</h3>
                        </a>
                    </p>
                    <p>
                        Селекторний канал (СК) на відміну від МК працює в
                        монопольному режимі. ЗЗП, що підключаються до СК, можуть
                        працювати спільно в часі лише під час виконання
                        підготовчих операцій, таких як підведення стрічки,
                        встановлення механізму доступу на заданий циліндр пакета
                        магнітних дисків тощо. Під час передавання даних СК
                        обслуговує в кожен момент часу звернення тільки до
                        одного ЗЗП. Модель роботи СК розглянемо на прикладі
                        каналу з однотипним ЗЗП (рис. 5.13, а).
                    </p>
                    <p>
                        Модель повинна відображати різні етапи в обробці запитів
                        програм на введення-виведення інформації: на першому
                        етапі виконуються підготовчі операції; на другому -
                        передача інформації між оперативною пам'яттю та одним із
                        ЗЗП. У результаті процес роботи каналу і ЗЗП можна
                        представити як процес послідовного обслуговування
                        запитів у двох СМО (рис. 5.13, б), перша з яких
                        відображає етап виконання підготовчих операцій у ЗЗП, і
                        друга - етап передавання даних (ПД) каналом. Тривалість
                        цих етапів становить у середньому
                        <i>V<sub>1</sub></i>
                        і
                        <i>V<sub>2</sub></i>
                        одиниць часу відповідно. На вхід СК надходить потік
                        заявок з інтенсивністю
                        <i><span>l</span></i
                        ><span
                            >. Заявки з імовірністю
                            <i>P<sub>i</sub>, (i=1,k)</i>
                            спрямовуються в одну із систем ЗЗП<sub>i</sub> .
                        </span>
                    </p>
                    <p>
                        <span
                            >Розглянута модель - модель із блокуванням процесів
                            обслуговування заявок у різних системах:
                            ЗЗП<sub>i</sub>, який завершило підготовчу операцію,
                            не може почати обслуговування наступної заявки з
                            черги <i>Q</i><sub>i</sub> доти, доки канал, тобто
                            система ПД, не завершить передачу даних із ЗЗП<sub
                                >i</sub
                            >
                            . Ефектом блокування можна знехтувати, якщо
                            врахувати, що затримки під час передавання даних на
                            порядок менші за час виконання підготовчих операцій
                            у ЗЗП. У зв'язку з цим системи ЗЗП<sub>1</sub>, ...,
                            ЗЗП<sub>К</sub>
                            і ПД (рис. 5.13) можуть розглядатися як незалежні
                            СМО.
                        </span>
                    </p>
                    <div
                        class="d-flex align-items-center flex-column mb-3 mt-3"
                    >
                        <img src="formula/ris511.gif" />
                        <div class="mt-3">
                            Рис. 5.11 Модель мультиплексного каналу
                        </div>
                    </div>
                    <div
                        class="d-flex align-items-center flex-column mb-3 mt-3"
                    >
                        <img src="formula/ris512a.gif" />
                        <img src="formula/ris512b.gif" />
                        <div class="mt-3">
                            Рис. 5.12 Модель мультиплексногу каналу
                        </div>
                    </div>
                    <div
                        class="d-flex align-items-center flex-column mb-3 mt-3"
                    >
                        <img src="formula/ris513.gif" />
                        <div class="mt-3">
                            Рис. 5.13 Моделі селекторних каналів
                        </div>
                    </div>
                    <p>
                        <h3>Запитання для самоперевірки</h3>
                    </p>
                    <p>
                        1. Від чого залежить конкретна реалізація випадкового
                        процесу?
                    </p>
                    <p>2. Перелічіть вимоги до моделей програм.</p>
                    <p>
                        3. Що визначає значення ><i><span>q</span></i
                        ><span> ? </span>
                    </p>
                    <p>
                        4. Що визначають значення ймовірностей
                        <i>P<sub>0Н+1</sub></i>
                        і як вони обчислюються?
                    </p>
                    <p>5. Як обчислюються характеристики трудомісткості?</p>
                    <p>
                        6. Як оцінюються мінімальна і максимальна трудомісткості
                        алгоритму?
                    </p>
                    <p>
                        7. Що визначає середній час безперервного рахунку
                        програми?
                    </p>
                    <p>8. Зобразіть модель мультиплексного каналу.</p>
                </div>
                <div class="col-3 shadow side_frame bg-yellow">
                    <svg width="96" height="96" viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
                        <path d="M18.6347 42.7125V35.1516L41.3503 14.3999V42.287H35.7859V39.1121H25.9665L31.0071 34.006H35.7859V26.8705L18.6347 42.7125Z" fill="#212529">
                            
                        </path>
                        <path d="M51.5614 27.9224C57.0941 27.9224 60.8 32.3068 60.8 38.4659C60.8 43.2679 58.2685 47.5479 54.6148 48.383C53.4404 48.6701 52.7097 48.8006 52.3704 48.8006H50.6016V43.8942H51.8484C54.406 43.8942 55.6848 41.6759 55.6848 37.2132C55.6848 37.0827 55.5804 34.9688 54.1189 33.6378C53.5187 33.0897 52.9967 32.8287 52.5009 32.8287H48.6384V48.8006H43.4449V27.9224H51.5614Z" fill="#212529">
                            
                        </path>
                        <path d="M11.6386 27.9224C6.10591 27.9224 2.40002 32.2024 2.40002 38.4659C2.40002 39.0661 2.47832 39.9795 2.6349 41.18C3.05247 44.4162 5.68835 47.7567 8.5852 48.383C9.7596 48.6701 10.5164 48.8006 10.8296 48.8006H43.5574V43.8942H11.3255C8.79398 43.8942 7.51519 41.6759 7.51519 37.2132C7.51519 36.9522 7.67178 36.2737 7.98495 35.1775C8.27203 34.1858 9.70741 32.8287 10.6991 32.8287H17.3541L19.7551 27.9224H11.6386Z" fill="#212529">
                            
                        </path>
                    </svg>
                    <hr class="border-dark">
                    <p>
                        <a href="index.html" class="link-dark fs-5">
                            <b>Головна сторінка</b>
                        </a>
                    </p>
                    <p>
                        <a href="engine.html" class="link-dark fs-5">
                            <b>Розрахунок системи</b>
                        </a>
                    </p>
                    <p>
                        <a href="theory.html" class="link-dark fs-5">
                            <b>Теоретичні відомості</b>
                        </a>
                    </p>
                    <p class="tabbed-link">
                        <a href="theory_1.html" class="link-dark fs-5">
                            <b>1. Моделі черг в обчислювальних системах. Експоненційні системи зі змінними параметрами</b>
                        </a>
                    </p>
                    <p class="tabbed-link">
                        <a href="theory_2.html" class="link-dark fs-5">
                            <b>2. Теорія черг і розрахунок параметрів Intranet-мережі. Особливості застосування теорії черг і розрахунку параметрів Intranet-мережі</b>
                        </a>
                    </p>
                    <p class="tabbed-link">
                        <a href="theory_3.html" class="link-dark fs-5">
                            <b>3. Моделі програм. Методика моделювання ресурсів ВС. Моделі пристроїв-ресурсів і способи їх опису</b>
                        </a>
                    </p>
                    <p class="tabbed-link">
                        <a href="theory_4.html" class="link-dark fs-5">
                            <b>4. Канали зв'язку. Агрегування каналів</b>
                        </a>
                    </p>
                </div>
            </div>
        </div>

        <script type="text/javascript" async src="lib/tex-chtml.js"></script>
    </body>
</html>
